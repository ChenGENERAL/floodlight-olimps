package net.floodlightcontroller.flowcache;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;

import net.floodlightcontroller.flowcache.FlowCacheObj;

import org.junit.Test;

import org.openflow.protocol.OFMatch;
import org.openflow.protocol.Wildcards;
import org.openflow.protocol.Wildcards.Flag;
import org.openflow.protocol.action.OFAction;
import org.openflow.protocol.action.OFActionOutput;
import org.openflow.protocol.action.OFActionType;

public class FlowCacheObjTest {
	/** A standard cookie. */
	long cookie = 1L;
	/** A standard priority. */
	int priority_1 = 1;
	int priority_2 = 1;
	/** Wildcards, generated by the matching fields, i.e. the wildcards are the inverse. */
	int wildcards = (Wildcards.ofMatches(Flag.DL_TYPE, Flag.NW_SRC, Flag.NW_DST, Flag.NW_PROTO, Flag.TP_SRC, Flag.TP_DST)).getInt();
	/** OpenFlow matches.*/
	OFMatch match_1 = new OFMatch()
		.setDataLayerType((short) 1)
		.setNetworkSource(1)
		.setNetworkDestination(2)
		.setNetworkProtocol((byte) 1)
		.setTransportSource((short) 1)
		.setTransportDestination((short) 2)
		.setWildcards(wildcards);
	OFMatch match_2 = new OFMatch()
		.setDataLayerType((short) 1)
		.setNetworkSource(2)
		.setNetworkDestination(1)
		.setNetworkProtocol((byte) 1)
		.setTransportSource((short) 2)
		.setTransportDestination((short) 1)
		.setWildcards(wildcards);
	/** Port used by the output actions. */
	short port_1 = 2;
	short port_2 = 1;
	/** Output actions used by the flow cache objects. */
	OFActionOutput action_1 = new OFActionOutput()
		.setPort((short) port_1);
	OFActionOutput action_2 = new OFActionOutput()
		.setPort((short) port_2);
	/** List of output actions used by the flow cache objects. */
	List<OFAction> actionList_1 = new ArrayList<OFAction>(Arrays.asList(action_1));
	List<OFAction> actionList_2 = new ArrayList<OFAction>(Arrays.asList(action_2));
	List<OFAction> actionList_3 = new ArrayList<OFAction>(Arrays.asList(action_1, action_2));
	
	/** A standard flow cache object, as installed e.g. by the forwarding application. */
	FlowCacheObj fco_1 = new FlowCacheObj(cookie, priority_1, match_1, actionList_1);
	/** A standard flow cache object, as installed e.g. by the forwarding application. */
	FlowCacheObj fco_2 = new FlowCacheObj(cookie, priority_1, match_2, actionList_2);
	/** A standard flow cache object, as installed e.g. by the forwarding application. */
	FlowCacheObj fco_3 = new FlowCacheObj(cookie, priority_1, match_2, actionList_3);

	@Test
	public void SimpleMatchTest() {
		// Make sure the match hashes differ.
		if (match_1.hashCode() == match_2.hashCode()) {
			System.out.println("The hashes of match_1 and match_2 are equal: " + match_1.hashCode());
			fail("The match hashes are equal");
		}
	}
	
	@Test
	public void SimpleActionTest() {
		if (action_1.hashCode() == action_2.hashCode()) {
			System.out.println("The hashes of action_1 and action_2 are equal: " + action_1.hashCode());
			fail("The action hashes are equal");
		}
		
		// Check action type.
		if (action_1.getType() != OFActionType.OUTPUT) {
			fail("Action_1 is not of type OUTPUT");
		}
		if (action_2.getType() != OFActionType.OUTPUT) {
			fail("Action_2 is not of type OUTPUT");
		}
	}
	
	@Test
	public void SimpleGetActionTest() {
		if (fco_1.getActions().size() != 1) {
			fail("Action list size of fco_1 should be 1 but is " + fco_1.getActions().size());
		}
		if (!fco_1.getActions().contains(action_1)) {
			fail("Acktion list of fco_1 does not contain action_1 but "+ fco_1.getActions());
		}
		
		if (fco_3.getActions().size() != 2) {
			fail("Action list size of fco_3 should be 2 but is " + fco_3.getActions().size());
		}
		if (!fco_3.getActions().contains(action_1) && !fco_3.getActions().contains(action_2)) {
			fail("Acktion list of fco_1 does not contain action_1 and action_2 but "+ fco_2.getActions());
		}
	}
	
	@Test
	public void SimpleFcoEqualTest() {
		// Make sure fco_1 and fco_1 are equal.
		if (!fco_1.equals(fco_1)) {
			System.out.println("FCO_1 does not equal FCO_1: " + fco_1 + " != " + fco_1);
			fail("FCO_1 does not equal FCO_1");
		}
		
		// Make sure fco_1 and fco_2 differ.
		if (fco_1.equals(fco_2)) {
			System.out.println("FCO_1 equals FCO_2: " + fco_1 + " == " + fco_2);
			fail("FCO_1 equals FCO_2");
		}
		
		// Make sure fco_2 and fco_1 differ.
		if (fco_2.equals(fco_1)) {
			System.out.println("FCO_2 equals FCO_1: " + fco_2 + " == " + fco_1);
			fail("FCO_2 equals FCO_1");
		}
	}

	@Test
	public void ActionsToOutPortsTest() {
		Set<Integer> portSet_1 = FlowCacheObj.actionsToOutPorts(fco_1);
		if (portSet_1.size() != 1) {
			fail("Wrong number of output ports. Should be 1 but is " + portSet_1.size() + ".");
		}
		for (int port : portSet_1) {
			if (port != port_1) {
				fail("Wrong port extracted");
			}
		}
		
		Set<Integer> portSet_2 = FlowCacheObj.actionsToOutPorts(fco_3);
		if (portSet_2.size() != 2) {
			fail("Wrong number of output ports. Should be 2 but is " + portSet_2.size() + ".");
		}
		if (!portSet_2.contains(port_1)) {
			fail("PortSet_2 does not contain port_1 but " + portSet_2);
		}
		if (!portSet_2.contains(port_2)) {
			fail("PortSet_2 does not contain port_2 but " + portSet_2);
		}
	}
	
	@Test
	public void SimpleWildcardMatchTest() {
		if (match_1.getWildcardObj().getInt() != this.wildcards) {
			fail("Wildcards of match_1 do not match");
		}
		if (match_2.getWildcardObj().getInt() != this.wildcards) {
			fail("Wildcards of match_2 do not match");
		}
		
		// Add some fields to match_1.
		match_1.setDataLayerVirtualLan((short) 0).setDataLayerVirtualLanPriorityCodePoint((byte) 0);
		// Clone match_1 and modify added fields.
		OFMatch match_3 = match_1.clone()
				.setDataLayerVirtualLan((short) 1)
				.setDataLayerVirtualLanPriorityCodePoint((byte) 1);
		
		// Make sure match_1 and match_3 differ
		if (match_1.equals(match_3)) {
			fail("Match_1 and match_3 are equal, however, the should differ in wildcarded fields");
		}
		
		// Wildcard match_1 and match_3
		FlowCacheObj.wildcardMatch(match_1);
		FlowCacheObj.wildcardMatch(match_3);
		
		if (!match_1.equals(match_3)) {
			System.out.println("Match_1: " + match_1);
			System.out.println("Match_3: " + match_3);
			fail("Match_1 and match_3 differ, although the should be equal");
		}
	}
	
	@Test
	public void SimpleFcoHashTest() {
		// Make sure their hashes differ.
		if (fco_1.getId() == fco_2.getId()) {
			System.out.println("The hashes of FCO_1 and FCO_2 are equal: " + fco_1.getId());
			fail("The hashes are equal");
		}
	}

}
