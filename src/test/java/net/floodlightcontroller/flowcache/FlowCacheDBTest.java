package net.floodlightcontroller.flowcache;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

import net.floodlightcontroller.flowcache.FlowCacheDB;
import net.floodlightcontroller.flowcache.FlowCacheObj;
import net.floodlightcontroller.flowcache.FlowCacheQuery;
import net.floodlightcontroller.flowcache.FlowCacheQueryResp;
import net.floodlightcontroller.flowcache.IFlowCacheService;
import net.floodlightcontroller.flowcache.IFlowQueryHandler;

import org.junit.Test;

import org.openflow.protocol.OFMatch;
import org.openflow.protocol.Wildcards;
import org.openflow.protocol.Wildcards.Flag;
import org.openflow.protocol.action.OFAction;
import org.openflow.protocol.action.OFActionOutput;

public class FlowCacheDBTest {
	/** The flow cache database to test. */
	FlowCacheDB flowCacheDB = new FlowCacheDB("default");
	/** A standard switch id. */
	long switchId_1 = 1L;
	long switchId_2 = 2L;
	/** A standard cookie. */
	long cookie = 1L;
	/** A standard priority. */
	int priority_1 = 1;
	int priority_2 = 1;
	/** Wildcards, generated by the matching fields, i.e. the wildcards are the inverse. */
	int wildcards = (Wildcards.ofMatches(Flag.DL_TYPE, Flag.NW_SRC, Flag.NW_DST, Flag.NW_PROTO, Flag.TP_SRC, Flag.TP_DST)).getInt();
	/** OpenFlow matches.*/
	OFMatch match_1 = new OFMatch()
		.setDataLayerType((short) 1)
		.setNetworkSource(1)
		.setNetworkDestination(2)
		.setNetworkProtocol((byte) 1)
		.setTransportSource((short) 1)
		.setTransportDestination((short) 2)
		.setWildcards(wildcards);
	OFMatch match_2 = new OFMatch()
		.setDataLayerType((short) 1)
		.setNetworkSource(2)
		.setNetworkDestination(1)
		.setNetworkProtocol((byte) 1)
		.setTransportSource((short) 2)
		.setTransportDestination((short) 1)
		.setWildcards(wildcards);
	/** Port used by the output actions. */
	short port_1 = 2;
	short port_2 = 1;
	/** Output actions used by the flow cache objects. */
	OFActionOutput action_1 = new OFActionOutput()
		.setPort((short) port_1);
	OFActionOutput action_2 = new OFActionOutput()
		.setPort((short) port_2);
	/** List of output actions used by the flow cache objects. */
	List<OFAction> actionList_1 = new ArrayList<OFAction>(Arrays.asList(action_1));
	List<OFAction> actionList_2 = new ArrayList<OFAction>(Arrays.asList(action_2));
	List<OFAction> actionList_3 = new ArrayList<OFAction>(Arrays.asList(action_1, action_2));
	
	/** A standard flow cache object, as installed e.g. by the forwarding application. */
	FlowCacheObj fco_1 = new FlowCacheObj(cookie, priority_1, match_1, actionList_1);
	/** A standard flow cache object, as installed e.g. by the forwarding application. */
	FlowCacheObj fco_2 = new FlowCacheObj(cookie, priority_1, match_2, actionList_2);
	/** A flow cache object, with the same match, but different action as fco_1. */
	FlowCacheObj fco_3 = new FlowCacheObj(cookie, priority_1, match_1, actionList_2);
	/** A flow cache object, similar (i.e. same hash) to fco_1, as generated by a flow remove message. */
	FlowCacheObj fco_4 = new FlowCacheObj(cookie, priority_1, match_1, null);
	/** A flow cache object, similar (i.e. same hash) to fco_2, as generated by a flow remove message. */
	FlowCacheObj fco_5 = new FlowCacheObj(cookie, priority_1, match_2, null);
	/** A flow cache object, as generated by a flow remove message. */
	FlowCacheObj fco_6 = new FlowCacheObj(cookie, priority_1, match_1, actionList_3);
	
	/**
	 * Just a dummy flow query handler that does nothing.
	 */
	protected class dummyQueryHandler implements IFlowQueryHandler {
		@Override
		public void flowQueryRespHandler(FlowCacheQueryResp resp) {
			// NO-OP
		}
	}
	
	@Test
	public void SimpleMatchTest() {
		// Make sure the match hashes differ.
		if (match_1.hashCode() == match_2.hashCode()) {
			System.out.println("The hashes of match_1 and match_2 are equal: " + match_1.hashCode());
			fail("The match hashes if match_1 and match_2 are equal");
		}
	}
	
	@Test
	public void SimpleActionTest() {
		if (action_1.hashCode() == action_2.hashCode()) {
			System.out.println("The hashes of action_1 and action_2 are equal: " + action_1.hashCode());
			fail("The action hashes are equal");
		}
	}
	
	@Test
	public void SimpleFcoTest() {
		// Make sure fco_1 and fco_2 differ.
		if (fco_1.equals(fco_2)) {
			System.out.println("FCO_1 equals FCO_2");
			fail("FCO_1 equals FCO_2");
		}
		// Make sure their hashes differ.
		if (fco_1.getId() == fco_2.getId()) {
			System.out.println("The hashes of FCO_1 and FCO_2 are equal: " + fco_1.getId());
			fail("The hashes are equal");
		}
		// Make sure fco_1 and fco_3 are the same.
		if (fco_1.getId() != fco_3.getId()) {
			fail("The hashes of fco_1 and fco_3 are NOT equal");
		}
		// Make sure fco_1 and fco_4 are the same.
		if (fco_1.getId() != fco_4.getId()) {
			fail("The hashes of fco_1 and fco_4 are NOT equal");
		}
		// Make sure fco_2 and fco_5 are the same.
		if (fco_2.getId() != fco_5.getId()) {
			fail("The hashes of fco_2 and fco_5 are NOT equal");
		}
	}

	@Test
	public void SimpleStoreTest() {
		// Populate the database.
		boolean stored_1 = this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		if (!stored_1) {
			fail("Was not able to actully store the entry.");
		}
		// Get all entries from the database.
		Set<FlowCacheObj> fcoSet = this.flowCacheDB.getAllEntries().get(switchId_1);
		
		if (fcoSet == null || fcoSet.size() != 1) {
			fail("Number of store cache entries not correct. Should be 1 but is " + fcoSet.size());
		}
		
		for (FlowCacheObj fco : fcoSet) {
			if (!fco.equals(fco_1)) {
				System.out.println("Original flow cache object: " + fco_1);
				System.out.println("Stored flow cache object:   " + fco);
				
				fail("Flow cache objects differ");
			}
		}
		
		assert(true);
	}
	
	@Test
	public void SimpleClearTest () {
		this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		this.flowCacheDB.clear();
		Map<Long, Set<FlowCacheObj>> fcoMap = this.flowCacheDB.getAllEntries();
		
		if (fcoMap.size() != 0) {
			System.out.println("flow cache object map: " + fcoMap);
			fail("Did not clear flow cache db");
		}
		
		assert(true);
	}
	
	@Test
	public void SimpleRemoveTest() {
		// Populate database.
		this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		// Remove the same entry from the database.
		FlowCacheObj fco = this.flowCacheDB.removeEntry(switchId_1, fco_1);
		
		if (!fco.equals(fco_1)) {		
			fail("Flow cache objects differ");
		}
		
		Map<Long, Set<FlowCacheObj>> fcoMap = this.flowCacheDB.getAllEntries();
		if (fcoMap.size() != 0) {
			System.out.println("flow cache object map: " + fcoMap);
			fail("Did not remove object from flow cache db");
		} 
		
		assert(true);
	}
	
	@Test
	public void SimpleHasEntryTest() {
		this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		
		// Test if the correct entry if found.
		if (!this.flowCacheDB.hasEntry(switchId_1, fco_1)) {
			fail("Flow cache says it does not have entry, although it should.");
		}
		// Test that a wrong entry (i.e. fco_2) is NOT found
		if (this.flowCacheDB.hasEntry(switchId_1, fco_2)) {
			fail("Flow cache says it does have entry (switchId_1, fco_2), although it should not.");
		}
		// Test that a wrong entry (i.e. switch_2) is NOT found
		if (this.flowCacheDB.hasEntry(switchId_2, fco_1)) {
			fail("Flow cache says it does have entry (switchId_2, fco_1), although it should not.");
		}
		// Test that a wrong entry (i.e. switch_2 and fco_2) is NOT found
		if (this.flowCacheDB.hasEntry(switchId_2, fco_2)) {
			fail("Flow cache says it does have entry (switchId_2, fco_2), although it should not.");
		}
		assert(true);
	}
	
	@Test
	public void StoreTwoDifferentEntriesOnSameSwitchTest() {
		// Populate database.
		boolean stored_1 = this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		if (!stored_1) {
			fail("Was not able to actully store the entry fco_1.");
		}
		boolean stored_2 = this.flowCacheDB.storeEntry(switchId_1, fco_2, true);
		if (!stored_2) {
			fail("Was not able to actully store the entry fco_2.");
		}
		// Get all entries from the database.
		Set<FlowCacheObj> fcoSet = this.flowCacheDB.getAllEntries().get(switchId_1);
		
		if (fcoSet == null || fcoSet.size() != 2) {
			fail("Number of store cache entries not correct. Should be 2, but is " + fcoSet.size());
		}
		
		for (FlowCacheObj fco : fcoSet) {
			boolean objCorrect_1 = false;
			boolean objCorrect_2 = false;
			
			if (fco.equals(fco_1)) {
				objCorrect_1 = true;
			} else if (fco.equals(fco_2)) {
				objCorrect_2 = true;
			}
			
			if (objCorrect_1 || objCorrect_2) {
				// NO-OP
			} else {
				if (!objCorrect_1) {
					System.out.println("Original flow cache object: " + fco_1);
					System.out.println("Stored flow cache object:   " + fco);
					
					fail("Flow cache objects differ");
				}
				if (!objCorrect_2) {
					System.out.println("Original flow cache object: " + fco_2);
					System.out.println("Stored flow cache object:   " + fco);
					
					fail("Flow cache objects differ");
				}
			}
		}
		
		assert(true);
	}
	
	/**
	 * If we write a flow cache object with the same hash value, we
	 * should override the existing entry.
	 */
	@Test
	public void StoreTwoSameEntriesOnSameSwitchTest() {
		// Populate database.
		boolean stored_1 = this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		if (!stored_1) {
			fail("Was not able to actully store the entry fco_1.");
		}
		boolean stored_2= this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		if (!stored_2) {
			fail("Was not able to override entry fco_1 with fco_1");
		}
		// Get all entries from the database.
		Set<FlowCacheObj> fcoSet = this.flowCacheDB.getAllEntries().get(switchId_1);
		
		if (fcoSet == null || fcoSet.size() != 1) {
			fail("Number of store cache entries not correct. Should be 1, but is " + fcoSet.size());
		}
				
		for (FlowCacheObj fco : fcoSet) {
			if (!fco.equals(fco_1)) {
				System.out.println("Original flow cache object: " + fco_1);
				System.out.println("Stored flow cache object:   " + fco);
				
				fail("Flow cache objects differ");
			}
		}
		
		assert(true);
	}
	
	@Test
	public void StoreTwoSameHashesButDifferentObjectOnSameSwitchTest() {
		// Populate database.
		boolean stored_1 = this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		if (!stored_1) {
			fail("Was not able to actully store the entry fco_1.");
		}
		// Check that we can override with a different entry, if "overrideEntries" == true.
		boolean overrideEntries = true;
		boolean stored_2 = this.flowCacheDB.storeEntry(switchId_1, fco_3, overrideEntries);
		if (overrideEntries && !stored_2) {
			fail("Was not able to override entry fco_1 with fco_3, although I should be.");
		}
		// Check that we can NOT override with a different entry, if "overrideEntries" == false.
		overrideEntries = false;
		boolean stored_3 = this.flowCacheDB.storeEntry(switchId_1, fco_1, overrideEntries);
		if (!overrideEntries && stored_3) {
			fail("Was able to override entry fco_3 with fco_1, although I should not be.");
		}
		overrideEntries = true;
		
		// Now, we should have on database entry, i.e. fco_3. Thus, check.
		// Get all entries from the database.
		Set<FlowCacheObj> fcoSet = this.flowCacheDB.getAllEntries().get(switchId_1);
				
		if (fcoSet == null || fcoSet.size() != 1) {
			fail("Number of store cache entries not correct. Should be 1, but is " + fcoSet.size());
		}
						
		for (FlowCacheObj fco : fcoSet) {
			if (!fco.equals(fco_3)) {
				System.out.println("Original flow cache object: " + fco_3);
				System.out.println("Stored flow cache object:   " + fco);
				
				fail("Flow cache objects differ. We should have fco_3, but have " + fco);
			}
		}
		
		assert(true);
	}
	
	@Test
	public void StoreTwoDifferentEntriesOnDifferentSwitchesTest() {
		// Populate database.
		boolean stored_1 = this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		if (!stored_1) {
			fail("Was not able to actully store the entry fco_1.");
		}
		boolean stored_2 = this.flowCacheDB.storeEntry(switchId_2, fco_2, true);
		if (!stored_2) {
			fail("Was not able to actully store the entry fco_2.");
		}
		
		// Get all entries for switch_1 from the database.
		Set<FlowCacheObj> fcoSet_1 = this.flowCacheDB.getAllEntries().get(switchId_1);
		if (fcoSet_1 == null || fcoSet_1.size() != 1) {
			fail("Number of store cache entries for switch_1 are not correct. Should be 1, but is " + fcoSet_1.size());
		}
		// Get all entries for switch_2 from the database.
		Set<FlowCacheObj> fcoSet_2 = this.flowCacheDB.getAllEntries().get(switchId_2);
		if (fcoSet_2 == null || fcoSet_2.size() != 1) {
			fail("Number of store cache entries for switch_2 are not correct. Should be 1, but is " + fcoSet_1.size());
		}
		
		for (FlowCacheObj fco : fcoSet_1) {
			if (!fco.equals(fco_1)) {				
				fail("Flow cache objects for switch_1 differ");
			}
		}
		for (FlowCacheObj fco : fcoSet_2) {
			if (!fco.equals(fco_2)) {				
				fail("Flow cache objects for switch_2 differ");
			}
		}
		
		assert(true);
	}
	
	@Test
	public void StoreTwoSameEntriesOnDifferentSwitchesTest() {
		// Populate database.
		boolean stored_1 = this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		if (!stored_1) {
			fail("Was not able to actully store the entry fco_1.");
		}
		boolean stored_2 = this.flowCacheDB.storeEntry(switchId_2, fco_1, true);
		if (!stored_2) {
			fail("Was not able to actully store the entry fco_2.");
		}
		
		// Get all entries for switch_1 from the database.
		Set<FlowCacheObj> fcoSet_1 = this.flowCacheDB.getAllEntries().get(switchId_1);
		if (fcoSet_1 == null || fcoSet_1.size() != 1) {
			fail("Number of store cache entries for switch_1 are not correct. Should be 1, but is " + fcoSet_1.size());
		}
		// Get all entries for switch_2 from the database.
		Set<FlowCacheObj> fcoSet_2 = this.flowCacheDB.getAllEntries().get(switchId_2);
		if (fcoSet_2 == null || fcoSet_2.size() != 1) {
			fail("Number of store cache entries for switch_2 are not correct. Should be 1, but is " + fcoSet_1.size());
		}
				
		for (FlowCacheObj fco : fcoSet_1) {
			if (!fco.equals(fco_1)) {				
				fail("Flow cache objects for switch_1 differ");
			}
		}
		for (FlowCacheObj fco : fcoSet_2) {
			if (!fco.equals(fco_1)) {				
				fail("Flow cache objects for switch_2 differ");
			}
		}
		
		assert(true);
	}
	
	@Test
	public void RemoveDifferentObjectTest() {
		// Populate database.
		boolean stored_1 = this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		if (!stored_1) {
			fail("Was not able to actully store the entry fco_1.");
		}
		
		// Remove a different object from the database.
		FlowCacheObj fco = this.flowCacheDB.removeEntry(switchId_1, fco_2);
		if (fco != null) {
			fail("We should have not been able to remove the object. However, we got: " + fco);
		}
		
		// Get all entries from the database.
		Set<FlowCacheObj> fcoSet = this.flowCacheDB.getAllEntries().get(switchId_1);
		if (fcoSet == null || fcoSet.size() != 1) {
			fail("Number of store cache entries not correct. Should be 1, but is " + fcoSet.size());
		}
		
		// Check that fco_1 is still in the database.
		if (!this.flowCacheDB.hasEntry(switchId_1, fco_1)) {
			fail("The installed object is not there any more.");
		}
		
		assert(true);
	}
	
	@Test
	public void RemoveDifferentObjectButSameHashTest() {
		// Populate database.
		boolean stored_1 = this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		if (!stored_1) {
			fail("Was not able to actully store the entry fco_1.");
		}
		
		// Remove a different object from the database.
		FlowCacheObj fco = this.flowCacheDB.removeEntry(switchId_1, fco_4);
		if (fco == null) {
			fail("We should have been able to remove the object. However, we got: " + fco);
		}
		
		if (!this.flowCacheDB.isEmpty()) {
			fail("The database should be empty but is not.");
		}
		
		assert(true);
	}

	@Test
	public void SimpleQueryDBTest() {
		// Populate database.
		boolean stored_1 = this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		if (!stored_1) {
			fail("Was not able to actully store the entry fco_1.");
		}
		
		// Create flow cache query.
		FlowCacheQuery fcq = new FlowCacheQuery(new dummyQueryHandler(), IFlowCacheService.DEFAULT_DB_NAME, "test", null, switchId_1);
		Map<Long, Set<FlowCacheObj>> queryResult = this.flowCacheDB.queryDB(switchId_1, fcq);
		
		if (queryResult.size() != 1) {
			fail("Resulting query map size does not equal 1: " + queryResult);
		}
		
		if (queryResult.get(switchId_1) == null) {
			fail("Resulting query map contains wrong key: " + queryResult.keySet());
		}
		
		if (queryResult.get(switchId_1).size() != 1) {
			if (queryResult.size() != 1) {
				fail("Resulting query map size for the switch does not equal 1: " + queryResult.values());
			}
		}
		
		for (FlowCacheObj fco : queryResult.get(switchId_1)) {
			if (!fco.equals(fco_1)) {
				fail("Resulting query result flow cache object is not what we have expected: " + fco);
			}
		}
	}
	
	@Test
	public void SimpleOutPortQueryDBTest() {
		// Populate database.
		boolean stored_1 = this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		if (!stored_1) {
			fail("Was not able to actully store the entry fco_1.");
		}
		boolean stored_2 = this.flowCacheDB.storeEntry(switchId_1, fco_2, true);
		if (!stored_2) {
			fail("Was not able to actully store the entry fco_2.");
		}
		
		// Create flow cache query.
		FlowCacheQuery fcq = new FlowCacheQuery(new dummyQueryHandler(), IFlowCacheService.DEFAULT_DB_NAME, "test", null, switchId_1)
			.setOutPort(port_1);
		Map<Long, Set<FlowCacheObj>> queryResult = this.flowCacheDB.queryDB(switchId_1, fcq);
		
		if (queryResult.size() != 1) {
			fail("Resulting query map size does not equal 1: " + queryResult);
		}
		
		if (queryResult.get(switchId_1) == null) {
			fail("Resulting query map contains wrong key: " + queryResult.keySet());
		}
		
		if (queryResult.get(switchId_1).size() != 1) {
			if (queryResult.size() != 1) {
				fail("Resulting query map size for the switch does not equal 1: " + queryResult.values());
			}
		}
		
		for (FlowCacheObj fco : queryResult.get(switchId_1)) {
			if (!fco.equals(fco_1)) {
				fail("Resulting query result flow cache object is not what we have expected: " + fco);
			}
		}
	}
	
	@Test
	public void FailedOutPortQueryDBTest() {
		boolean stored_4 = this.flowCacheDB.storeEntry(switchId_1, fco_4, true);
		if (!stored_4) {
			fail("Was not able to store the entry fco_4.");
		}
		
		// Create flow cache query.
		FlowCacheQuery fcq = new FlowCacheQuery(new dummyQueryHandler(), IFlowCacheService.DEFAULT_DB_NAME, "test", null, switchId_1)
			.setOutPort(port_1);
		Map<Long, Set<FlowCacheObj>> queryResult = this.flowCacheDB.queryDB(switchId_1, fcq);
		
		if (queryResult != null) {
			fail("Resulting query map is not null: " + queryResult);
		}
		
		assert(true);
	}
	
	@Test
	public void PathIdSingleSwitchQueryDBTest() {
		// The path Id to query for.
		int pathId = 1;
		// Populate database.
		fco_1.setPathId(pathId);
		boolean stored_1 = this.flowCacheDB.storeEntry(switchId_1, fco_1, true);
		if (!stored_1) {
			fail("Was not able to store the entry fco_1.");
		}
		fco_2.setPathId(pathId);
		boolean stored_2 = this.flowCacheDB.storeEntry(switchId_1, fco_2, true);
		if (!stored_2) {
			fail("Was not able to store the entry fco_2.");
		}
		
		// Create flow cache query.
		FlowCacheQuery fcq = new FlowCacheQuery(new dummyQueryHandler(), IFlowCacheService.DEFAULT_DB_NAME, "test", null, switchId_1)
			.setPathId(pathId);
		Map<Long, Set<FlowCacheObj>> queryResult = this.flowCacheDB.queryDB(switchId_1, fcq);
		
		if (queryResult.size() != 1) {
			fail("Resulting query map size does not equal 1: " + queryResult);
		}
		
		if (queryResult.get(switchId_1) == null) {
			fail("Resulting query map contains wrong key: " + queryResult.keySet());
		}

		if (queryResult.get(switchId_1).size() != 2) {
			if (queryResult.size() != 1) {
				fail("Resulting query map size for the switch does not equal 2: " + queryResult.values());
			}
		}
		
		for (FlowCacheObj fco : queryResult.get(switchId_1)) {
			
			if (!(fco.equals(fco_1) || fco.equals(fco_2))) {
				fail("Resulting query result flow cache object is not what we have expected: " + fco);
			}
		}
	}
	
}